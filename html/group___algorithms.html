<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>BoltView: Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">BoltView
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group___algorithms.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Algorithms</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga319d2dfacd54de6c44ab5c986291fe0e"><td class="memTemplParams" colspan="2">template&lt;typename TView , typename TOutputValue , typename TOperator &gt; </td></tr>
<tr class="memitem:ga319d2dfacd54de6c44ab5c986291fe0e"><td class="memTemplItemLeft" align="right" valign="top">TOutputValue&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___algorithms.html#ga319d2dfacd54de6c44ab5c986291fe0e">bolt::reduce</a> (TView <a class="el" href="namespacebolt.html#aa174a77eeaf258383cd6cd6ce0696213">view</a>, TOutputValue initial_value, TOperator reduction_operator, <a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a> execution_policy=<a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a>{})</td></tr>
<tr class="separator:ga319d2dfacd54de6c44ab5c986291fe0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5caad425978f8712c959c5de6bcd5d7f"><td class="memTemplParams" colspan="2">template&lt;typename TView , typename TOutputView , typename TOutputValue , int tDimension, typename TOperator &gt; </td></tr>
<tr class="memitem:ga5caad425978f8712c959c5de6bcd5d7f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___algorithms.html#ga5caad425978f8712c959c5de6bcd5d7f">bolt::dimensionReduce</a> (TView <a class="el" href="namespacebolt.html#aa174a77eeaf258383cd6cd6ce0696213">view</a>, TOutputView output_view, <a class="el" href="structbolt_1_1_dimension_value.html">DimensionValue</a>&lt; tDimension &gt; dimension, TOutputValue initial_value, TOperator reduction_operator, <a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a> execution_policy=<a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a>{})</td></tr>
<tr class="separator:ga5caad425978f8712c959c5de6bcd5d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fdd12b1900d9e972e76c72437bfaefe"><td class="memTemplParams" colspan="2">template&lt;typename TView , typename TOutputValue , class  = typename std::enable_if&lt;IsImageView&lt;TView&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ga1fdd12b1900d9e972e76c72437bfaefe"><td class="memTemplItemLeft" align="right" valign="top">TOutputValue&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___algorithms.html#ga1fdd12b1900d9e972e76c72437bfaefe">bolt::sum</a> (TView <a class="el" href="namespacebolt.html#aa174a77eeaf258383cd6cd6ce0696213">view</a>, TOutputValue initial_value, <a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a> execution_policy=<a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a>{})</td></tr>
<tr class="separator:ga1fdd12b1900d9e972e76c72437bfaefe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0dabfa34fdb5b9805ff6584b8def809"><td class="memTemplParams" colspan="2">template&lt;typename TView , class  = typename std::enable_if&lt;IsImageView&lt;TView&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:gac0dabfa34fdb5b9805ff6584b8def809"><td class="memTemplItemLeft" align="right" valign="top">TView::Element&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___algorithms.html#gac0dabfa34fdb5b9805ff6584b8def809">bolt::sum</a> (TView <a class="el" href="namespacebolt.html#aa174a77eeaf258383cd6cd6ce0696213">view</a>, <a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a> execution_policy=<a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a>{})</td></tr>
<tr class="separator:gac0dabfa34fdb5b9805ff6584b8def809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b93a90ee5c4d26c02c8509d04681425"><td class="memTemplParams" colspan="2">template&lt;typename TView1 , typename TView2 , typename TOutputValue &gt; </td></tr>
<tr class="memitem:ga7b93a90ee5c4d26c02c8509d04681425"><td class="memTemplItemLeft" align="right" valign="top">TOutputValue&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___algorithms.html#ga7b93a90ee5c4d26c02c8509d04681425">bolt::sumSquareDifferences</a> (TView1 view1, TView2 view2, TOutputValue initial_value, <a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a> execution_policy=<a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a>{})</td></tr>
<tr class="separator:ga7b93a90ee5c4d26c02c8509d04681425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4d64b52efe346e82dddc320c0bd22de"><td class="memTemplParams" colspan="2">template&lt;typename TView , class  = typename std::enable_if&lt;IsImageView&lt;TView&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:gad4d64b52efe346e82dddc320c0bd22de"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___algorithms.html#gad4d64b52efe346e82dddc320c0bd22de">bolt::isFinite</a> (TView <a class="el" href="namespacebolt.html#aa174a77eeaf258383cd6cd6ce0696213">view</a>, <a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a> execution_policy=<a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a>{})</td></tr>
<tr class="separator:gad4d64b52efe346e82dddc320c0bd22de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddb53bc140193857c3f2a1f83d7dd347"><td class="memTemplParams" colspan="2">template&lt;typename TView , typename TValue &gt; </td></tr>
<tr class="memitem:gaddb53bc140193857c3f2a1f83d7dd347"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___algorithms.html#gaddb53bc140193857c3f2a1f83d7dd347">bolt::fill</a> (TView <a class="el" href="namespacebolt.html#aa174a77eeaf258383cd6cd6ce0696213">view</a>, TValue value, cudaStream_t cuda_stream=nullptr)</td></tr>
<tr class="separator:gaddb53bc140193857c3f2a1f83d7dd347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga012c3ac1b72c7aa099ad27dc6ea74555"><td class="memTemplParams" colspan="2">template&lt;typename TInView , typename TOutView , typename TFilterOperator , typename TPolicy &gt; </td></tr>
<tr class="memitem:ga012c3ac1b72c7aa099ad27dc6ea74555"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___algorithms.html#ga012c3ac1b72c7aa099ad27dc6ea74555">bolt::filter</a> (TInView in_view, TOutView out_view, TFilterOperator filter_operator, TPolicy policy)</td></tr>
<tr class="separator:ga012c3ac1b72c7aa099ad27dc6ea74555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7be70b86acc46ddc421e0c1805a18868"><td class="memTemplParams" colspan="2">template&lt;typename TInView , typename TOutView , typename TFilterOperator &gt; </td></tr>
<tr class="memitem:ga7be70b86acc46ddc421e0c1805a18868"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___algorithms.html#ga7be70b86acc46ddc421e0c1805a18868">bolt::filter</a> (TInView in_view, TOutView out_view, TFilterOperator filter_operator)</td></tr>
<tr class="separator:ga7be70b86acc46ddc421e0c1805a18868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga409dd9b3fce93c06edd22aeb054d6c16"><td class="memTemplParams" colspan="2">template&lt;typename TView , typename TFunctor , typename TPolicy &gt; </td></tr>
<tr class="memitem:ga409dd9b3fce93c06edd22aeb054d6c16"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___algorithms.html#ga409dd9b3fce93c06edd22aeb054d6c16">bolt::forEach</a> (TView <a class="el" href="namespacebolt.html#aa174a77eeaf258383cd6cd6ce0696213">view</a>, TFunctor functor, TPolicy policy, cudaStream_t cuda_stream=nullptr)</td></tr>
<tr class="separator:ga409dd9b3fce93c06edd22aeb054d6c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7baa67e8c1908e70f3039fcb250dae86"><td class="memTemplParams" colspan="2">template&lt;typename TView , typename TFunctor &gt; </td></tr>
<tr class="memitem:ga7baa67e8c1908e70f3039fcb250dae86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___algorithms.html#ga7baa67e8c1908e70f3039fcb250dae86">bolt::forEach</a> (TView <a class="el" href="namespacebolt.html#aa174a77eeaf258383cd6cd6ce0696213">view</a>, TFunctor functor, cudaStream_t cuda_stream=nullptr)</td></tr>
<tr class="separator:ga7baa67e8c1908e70f3039fcb250dae86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad1858c687309e06c4e4434b2e1743b8d"><td class="memTemplParams" colspan="2">template&lt;typename TView , typename TFunctor , typename TPolicy &gt; </td></tr>
<tr class="memitem:gad1858c687309e06c4e4434b2e1743b8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___algorithms.html#gad1858c687309e06c4e4434b2e1743b8d">bolt::forEachPosition</a> (TView <a class="el" href="namespacebolt.html#aa174a77eeaf258383cd6cd6ce0696213">view</a>, TFunctor functor, TPolicy policy, cudaStream_t cuda_stream=nullptr)</td></tr>
<tr class="separator:gad1858c687309e06c4e4434b2e1743b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga038494adc91c161f2a0dc942feceaf15"><td class="memTemplParams" colspan="2">template&lt;typename TView , typename TFunctor &gt; </td></tr>
<tr class="memitem:ga038494adc91c161f2a0dc942feceaf15"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___algorithms.html#ga038494adc91c161f2a0dc942feceaf15">bolt::forEachPosition</a> (TView <a class="el" href="namespacebolt.html#aa174a77eeaf258383cd6cd6ce0696213">view</a>, TFunctor functor, cudaStream_t cuda_stream=nullptr)</td></tr>
<tr class="separator:ga038494adc91c161f2a0dc942feceaf15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8988c894cadec3489da48da940e29e4e"><td class="memTemplParams" colspan="2">template&lt;typename TView , typename TFunctor , typename TPolicy &gt; </td></tr>
<tr class="memitem:ga8988c894cadec3489da48da940e29e4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___algorithms.html#ga8988c894cadec3489da48da940e29e4e">bolt::forEachLocator</a> (TView <a class="el" href="namespacebolt.html#aa174a77eeaf258383cd6cd6ce0696213">view</a>, TFunctor functor, TPolicy policy, cudaStream_t cuda_stream=nullptr)</td></tr>
<tr class="separator:ga8988c894cadec3489da48da940e29e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac463fba8b97c8e90619765effdfe302a"><td class="memTemplParams" colspan="2">template&lt;typename TView , typename TFunctor &gt; </td></tr>
<tr class="memitem:gac463fba8b97c8e90619765effdfe302a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___algorithms.html#gac463fba8b97c8e90619765effdfe302a">bolt::forEachLocator</a> (TView <a class="el" href="namespacebolt.html#aa174a77eeaf258383cd6cd6ce0696213">view</a>, TFunctor functor, cudaStream_t cuda_stream=nullptr)</td></tr>
<tr class="separator:gac463fba8b97c8e90619765effdfe302a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39f66ea086f5d76ed6607166553b1e2d"><td class="memTemplParams" colspan="2">template&lt;typename TInView , typename TOutView , typename TFunctor , typename TPolicy &gt; </td></tr>
<tr class="memitem:ga39f66ea086f5d76ed6607166553b1e2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___algorithms.html#ga39f66ea086f5d76ed6607166553b1e2d">bolt::transform</a> (TInView in_view, TOutView out_view, TFunctor functor, TPolicy policy, cudaStream_t cuda_stream=nullptr)</td></tr>
<tr class="separator:ga39f66ea086f5d76ed6607166553b1e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3262130106da6b02db0b3798a771ab5"><td class="memTemplParams" colspan="2">template&lt;typename TInView , typename TOutView , typename TFunctor &gt; </td></tr>
<tr class="memitem:gad3262130106da6b02db0b3798a771ab5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___algorithms.html#gad3262130106da6b02db0b3798a771ab5">bolt::transform</a> (TInView in_view, TOutView out_view, TFunctor functor, cudaStream_t cuda_stream=nullptr)</td></tr>
<tr class="separator:gad3262130106da6b02db0b3798a771ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16275587bbe5ea1b2cb24705550761e2"><td class="memTemplParams" colspan="2">template&lt;typename TInView , typename TOutView , typename TFunctor , typename TPolicy &gt; </td></tr>
<tr class="memitem:ga16275587bbe5ea1b2cb24705550761e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___algorithms.html#ga16275587bbe5ea1b2cb24705550761e2">bolt::transformPosition</a> (TInView in_view, TOutView out_view, TFunctor functor, TPolicy policy, cudaStream_t cuda_stream=nullptr)</td></tr>
<tr class="separator:ga16275587bbe5ea1b2cb24705550761e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae882322e35cc449a26a77adbf658bee2"><td class="memTemplParams" colspan="2">template&lt;typename TInView , typename TOutView , typename TFunctor &gt; </td></tr>
<tr class="memitem:gae882322e35cc449a26a77adbf658bee2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___algorithms.html#gae882322e35cc449a26a77adbf658bee2">bolt::transformPosition</a> (TInView in_view, TOutView out_view, TFunctor functor, cudaStream_t cuda_stream=nullptr)</td></tr>
<tr class="separator:gae882322e35cc449a26a77adbf658bee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeaa21855f71fa44b348407589b1f8076"><td class="memTemplParams" colspan="2">template&lt;typename TInView , typename TOutView , typename TFunctor , typename TPolicy &gt; </td></tr>
<tr class="memitem:gaeaa21855f71fa44b348407589b1f8076"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___algorithms.html#gaeaa21855f71fa44b348407589b1f8076">bolt::transformLocator</a> (TInView in_view, TOutView out_view, TFunctor functor, TPolicy policy, cudaStream_t cuda_stream=nullptr)</td></tr>
<tr class="separator:gaeaa21855f71fa44b348407589b1f8076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ce7350791f453c362f8761488f58996"><td class="memTemplParams" colspan="2">template&lt;typename TInView , typename TOutView , typename TFunctor &gt; </td></tr>
<tr class="memitem:ga6ce7350791f453c362f8761488f58996"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___algorithms.html#ga6ce7350791f453c362f8761488f58996">bolt::transformLocator</a> (TInView in_view, TOutView out_view, TFunctor functor, cudaStream_t cuda_stream=nullptr)</td></tr>
<tr class="separator:ga6ce7350791f453c362f8761488f58996"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5caad425978f8712c959c5de6bcd5d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5caad425978f8712c959c5de6bcd5d7f">&#9670;&nbsp;</a></span>dimensionReduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TView , typename TOutputView , typename TOutputValue , int tDimension, typename TOperator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bolt::dimensionReduce </td>
          <td>(</td>
          <td class="paramtype">TView&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputView&#160;</td>
          <td class="paramname"><em>output_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbolt_1_1_dimension_value.html">DimensionValue</a>&lt; tDimension &gt;&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputValue&#160;</td>
          <td class="paramname"><em>initial_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOperator&#160;</td>
          <td class="paramname"><em>reduction_operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a>&#160;</td>
          <td class="paramname"><em>execution_policy</em> = <code><a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaddb53bc140193857c3f2a1f83d7dd347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddb53bc140193857c3f2a1f83d7dd347">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TView , typename TValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bolt::fill </td>
          <td>(</td>
          <td class="paramtype">TView&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TValue&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>cuda_stream</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns the same value to each element in passed view </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>Processed image view </td></tr>
    <tr><td class="paramname">value</td><td>Value assigned to all image elements </td></tr>
    <tr><td class="paramname">cuda_stream</td><td>Id of the cuda stream on which the code will be executed (valid only for device/hybrid views) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7be70b86acc46ddc421e0c1805a18868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7be70b86acc46ddc421e0c1805a18868">&#9670;&nbsp;</a></span>filter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInView , typename TOutView , typename TFilterOperator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bolt::filter </td>
          <td>(</td>
          <td class="paramtype">TInView&#160;</td>
          <td class="paramname"><em>in_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutView&#160;</td>
          <td class="paramname"><em>out_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFilterOperator&#160;</td>
          <td class="paramname"><em>filter_operator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each element from input view apply spatial filter with bounded support (limited neighborhood) - convolution, median filter, morphological operations, etc. Size of filter mask should be known in compile time, so the execution can be internaly optimized by preloading to shared memory. Too large neighborhood causes fallback to TransformLocator. Input view must be same or bigger then the output view. Accessed memory for input and output view must be different otherwise it can introduce race conditions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_view</td><td>Input view - can be read only </td></tr>
    <tr><td class="paramname">out_view</td><td>Output view - needs write access to its elements </td></tr>
    <tr><td class="paramname">filter_operator</td><td>Filter operator - it accesses element neighborhood by using image locators </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>TransformLocator </dd></dl>

</div>
</div>
<a id="ga012c3ac1b72c7aa099ad27dc6ea74555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga012c3ac1b72c7aa099ad27dc6ea74555">&#9670;&nbsp;</a></span>filter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInView , typename TOutView , typename TFilterOperator , typename TPolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bolt::filter </td>
          <td>(</td>
          <td class="paramtype">TInView&#160;</td>
          <td class="paramname"><em>in_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutView&#160;</td>
          <td class="paramname"><em>out_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFilterOperator&#160;</td>
          <td class="paramname"><em>filter_operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPolicy&#160;</td>
          <td class="paramname"><em>policy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For each element from input view apply spatial filter with bounded support (limited neighborhood) - convolution, median filter, morphological operations, etc. Size of filter mask should be known in compile time, so the execution can be internaly optimized by preloading to shared memory. Too large neighborhood causes fallback to TransformLocator. Input view must be same or bigger then the output view. Accessed memory for input and output view must be different otherwise it can introduce race conditions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_view</td><td>Input view - can be read only </td></tr>
    <tr><td class="paramname">out_view</td><td>Output view - needs write access to its elements </td></tr>
    <tr><td class="paramname">filter_operator</td><td>Filter operator - it accesses element neighborhood by using image locators </td></tr>
    <tr><td class="paramname">policy</td><td>Policy describing kernel execution configuration and boundary problem handling configuration in image locators. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>TransformLocator </dd></dl>

</div>
</div>
<a id="ga7baa67e8c1908e70f3039fcb250dae86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7baa67e8c1908e70f3039fcb250dae86">&#9670;&nbsp;</a></span>forEach() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TView , typename TFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bolt::forEach </td>
          <td>(</td>
          <td class="paramtype">TView&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunctor&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>cuda_stream</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply functor on each element in passed view </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>Processed image view </td></tr>
    <tr><td class="paramname">functor</td><td>functor which is called on each element. Whether it get reference or const reference for the processed element depends on type of the view. </td></tr>
    <tr><td class="paramname">cuda_stream</td><td>Id of the cuda stream on which the code will be executed (valid only for device/hybrid views) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga409dd9b3fce93c06edd22aeb054d6c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga409dd9b3fce93c06edd22aeb054d6c16">&#9670;&nbsp;</a></span>forEach() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TView , typename TFunctor , typename TPolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bolt::forEach </td>
          <td>(</td>
          <td class="paramtype">TView&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunctor&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPolicy&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>cuda_stream</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply functor on each element in passed view </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>Processed image view </td></tr>
    <tr><td class="paramname">functor</td><td>functor which is called on each element. Whether it get reference or const reference for the processed element depends on type of the view. </td></tr>
    <tr><td class="paramname">policy</td><td>You can specify kernel execution configuration. </td></tr>
    <tr><td class="paramname">cuda_stream</td><td>Id of the cuda stream on which the code will be executed (valid only for device/hybrid views) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac463fba8b97c8e90619765effdfe302a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac463fba8b97c8e90619765effdfe302a">&#9670;&nbsp;</a></span>forEachLocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TView , typename TFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bolt::forEachLocator </td>
          <td>(</td>
          <td class="paramtype">TView&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunctor&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>cuda_stream</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies an operation for each each element of the view. The operator is supplied an image locator, so the relative element neighborhood is available. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>Processed image view. </td></tr>
    <tr><td class="paramname">functor</td><td>Applied callable object </td></tr>
    <tr><td class="paramname">cuda_stream</td><td>Which stream should schedule this operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8988c894cadec3489da48da940e29e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8988c894cadec3489da48da940e29e4e">&#9670;&nbsp;</a></span>forEachLocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TView , typename TFunctor , typename TPolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bolt::forEachLocator </td>
          <td>(</td>
          <td class="paramtype">TView&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunctor&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPolicy&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>cuda_stream</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies an operation for each each element of the view. The operator is supplied an image locator, so the relative element neighborhood is available, thus allowing implementation of filters like convolution. In this case the views cannot map the same memory block, because it can introduce race conditions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>Processed image view. </td></tr>
    <tr><td class="paramname">functor</td><td>Applied callable object </td></tr>
    <tr><td class="paramname">policy</td><td>Policy class describing kernel execution configuration. </td></tr>
    <tr><td class="paramname">cuda_stream</td><td>Which stream should schedule this operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga038494adc91c161f2a0dc942feceaf15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga038494adc91c161f2a0dc942feceaf15">&#9670;&nbsp;</a></span>forEachPosition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TView , typename TFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bolt::forEachPosition </td>
          <td>(</td>
          <td class="paramtype">TView&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunctor&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>cuda_stream</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply functor on each element in passed view together with the element's coordinate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>Processed image view </td></tr>
    <tr><td class="paramname">functor</td><td>functor which is called on each element and its index. Whether it get reference or const reference for the processed element depends on type of the view. </td></tr>
    <tr><td class="paramname">cuda_stream</td><td>Id of the cuda stream on which the code will be executed (valid only for device/hybrid views) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad1858c687309e06c4e4434b2e1743b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad1858c687309e06c4e4434b2e1743b8d">&#9670;&nbsp;</a></span>forEachPosition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TView , typename TFunctor , typename TPolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bolt::forEachPosition </td>
          <td>(</td>
          <td class="paramtype">TView&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunctor&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPolicy&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>cuda_stream</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply functor on each element in passed view together with the element's coordinate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>Processed image view </td></tr>
    <tr><td class="paramname">functor</td><td>functor which is called on each element and its index. Whether it get reference or const reference for the processed element depends on type of the view. </td></tr>
    <tr><td class="paramname">policy</td><td>You can specify kernel execution configuration. </td></tr>
    <tr><td class="paramname">cuda_stream</td><td>Id of the cuda stream on which the code will be executed (valid only for device/hybrid views) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad4d64b52efe346e82dddc320c0bd22de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4d64b52efe346e82dddc320c0bd22de">&#9670;&nbsp;</a></span>isFinite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TView , class  = typename std::enable_if&lt;IsImageView&lt;TView&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bolt::isFinite </td>
          <td>(</td>
          <td class="paramtype">TView&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a>&#160;</td>
          <td class="paramname"><em>execution_policy</em> = <code><a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga319d2dfacd54de6c44ab5c986291fe0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga319d2dfacd54de6c44ab5c986291fe0e">&#9670;&nbsp;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TView , typename TOutputValue , typename TOperator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TOutputValue bolt::reduce </td>
          <td>(</td>
          <td class="paramtype">TView&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputValue&#160;</td>
          <td class="paramname"><em>initial_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOperator&#160;</td>
          <td class="paramname"><em>reduction_operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a>&#160;</td>
          <td class="paramname"><em>execution_policy</em> = <code><a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implements parallel reduction - application of associative operator on all image elements. For example to sum all values in integer image: </p><div class="fragment"><div class="line"><a class="code" href="group___vector_operations.html#gae14379204bbc3f89b945a150de5c6a87">sum</a> = <a class="code" href="group___algorithms.html#ga319d2dfacd54de6c44ab5c986291fe0e">reduce</a>(<a class="code" href="namespacebolt.html#aa174a77eeaf258383cd6cd6ce0696213">view</a>, 0, thrust::plus&lt;int&gt;());</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">view</td><td>Processed image view - only constant element access needed. </td></tr>
    <tr><td class="paramname">initial_value</td><td>Value used for result initialization (0 for sums, 1 for products, etc.) </td></tr>
    <tr><td class="paramname">reduction_operator</td><td>Associative operator - it must be callable on device like this: result = reduction_operator(val1, val2). </td></tr>
    <tr><td class="paramname">execution_policy</td><td>Policy which can influence the execution (thread counts, tec.) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result of the operation. </dd></dl>

</div>
</div>
<a id="gac0dabfa34fdb5b9805ff6584b8def809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac0dabfa34fdb5b9805ff6584b8def809">&#9670;&nbsp;</a></span>sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TView , class  = typename std::enable_if&lt;IsImageView&lt;TView&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TView::Element bolt::sum </td>
          <td>(</td>
          <td class="paramtype">TView&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a>&#160;</td>
          <td class="paramname"><em>execution_policy</em> = <code><a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>WARNING: as a result type is used element type of the passed view, so be aware of possible overflow if summing large view of small type elements (int8_t, int16_t, ...) When in doubt use sum(view, initial_value); and pass initial value of bigger type to prevent overflows. </p>

</div>
</div>
<a id="ga1fdd12b1900d9e972e76c72437bfaefe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fdd12b1900d9e972e76c72437bfaefe">&#9670;&nbsp;</a></span>sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TView , typename TOutputValue , class  = typename std::enable_if&lt;IsImageView&lt;TView&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TOutputValue bolt::sum </td>
          <td>(</td>
          <td class="paramtype">TView&#160;</td>
          <td class="paramname"><em>view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputValue&#160;</td>
          <td class="paramname"><em>initial_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a>&#160;</td>
          <td class="paramname"><em>execution_policy</em> = <code><a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga7b93a90ee5c4d26c02c8509d04681425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7b93a90ee5c4d26c02c8509d04681425">&#9670;&nbsp;</a></span>sumSquareDifferences()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TView1 , typename TView2 , typename TOutputValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TOutputValue bolt::sumSquareDifferences </td>
          <td>(</td>
          <td class="paramtype">TView1&#160;</td>
          <td class="paramname"><em>view1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TView2&#160;</td>
          <td class="paramname"><em>view2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutputValue&#160;</td>
          <td class="paramname"><em>initial_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a>&#160;</td>
          <td class="paramname"><em>execution_policy</em> = <code><a class="el" href="structbolt_1_1_execution_policy.html">ExecutionPolicy</a>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gad3262130106da6b02db0b3798a771ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad3262130106da6b02db0b3798a771ab5">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInView , typename TOutView , typename TFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bolt::transform </td>
          <td>(</td>
          <td class="paramtype">TInView&#160;</td>
          <td class="paramname"><em>in_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutView&#160;</td>
          <td class="paramname"><em>out_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunctor&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>cuda_stream</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies an operation on each element of the input view and stores the result in the output view. Both views must have same size Input and output view can the same if the functor does not have side effects changing the data in passed views. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_view</td><td>Input view, can be read only. </td></tr>
    <tr><td class="paramname">functor</td><td>Applied callable object </td></tr>
    <tr><td class="paramname">out_view</td><td>Output view - must provide write access. </td></tr>
    <tr><td class="paramname">cuda_stream</td><td>Id of the cuda stream on which the code will be executed (valid only for device/hybrid views) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga39f66ea086f5d76ed6607166553b1e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39f66ea086f5d76ed6607166553b1e2d">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInView , typename TOutView , typename TFunctor , typename TPolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bolt::transform </td>
          <td>(</td>
          <td class="paramtype">TInView&#160;</td>
          <td class="paramname"><em>in_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutView&#160;</td>
          <td class="paramname"><em>out_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunctor&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPolicy&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>cuda_stream</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies an operation on each element of the input view and stores the result in the output view. Both views must have same size Input and output view can the same if the functor does not have side effects changing the data in passed views. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_view</td><td>Input view, can be read only. </td></tr>
    <tr><td class="paramname">out_view</td><td>Output view - must provide write access. </td></tr>
    <tr><td class="paramname">functor</td><td>Applied callable object </td></tr>
    <tr><td class="paramname">policy</td><td>Policy class describing kernel execution configuration. </td></tr>
    <tr><td class="paramname">cuda_stream</td><td>Id of the cuda stream on which the code will be executed (valid only for device/hybrid views) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6ce7350791f453c362f8761488f58996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ce7350791f453c362f8761488f58996">&#9670;&nbsp;</a></span>transformLocator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInView , typename TOutView , typename TFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bolt::transformLocator </td>
          <td>(</td>
          <td class="paramtype">TInView&#160;</td>
          <td class="paramname"><em>in_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutView&#160;</td>
          <td class="paramname"><em>out_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunctor&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>cuda_stream</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies an operation for each each element of the output view. The operator is supplied an image locator, so the relative element neighborhood is available, thus allowing implementation of filters like convolution. In this case the views cannot map the same memory block, because it can introduce race conditions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_view</td><td>Input view, can be read only. </td></tr>
    <tr><td class="paramname">out_view</td><td>Output view - must provide write access. </td></tr>
    <tr><td class="paramname">functor</td><td>Applied callable object </td></tr>
    <tr><td class="paramname">cuda_stream</td><td>Which stream should schedule this operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeaa21855f71fa44b348407589b1f8076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeaa21855f71fa44b348407589b1f8076">&#9670;&nbsp;</a></span>transformLocator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInView , typename TOutView , typename TFunctor , typename TPolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bolt::transformLocator </td>
          <td>(</td>
          <td class="paramtype">TInView&#160;</td>
          <td class="paramname"><em>in_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutView&#160;</td>
          <td class="paramname"><em>out_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunctor&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPolicy&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>cuda_stream</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies an operation for each each element of the output view. The operator is supplied an image locator, so the relative element neighborhood is available, thus allowing implementation of filters like convolution. In this case the views cannot map the same memory block, because it can introduce race conditions. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_view</td><td>Input view, can be read only. </td></tr>
    <tr><td class="paramname">out_view</td><td>Output view - must provide write access. </td></tr>
    <tr><td class="paramname">functor</td><td>Applied callable object </td></tr>
    <tr><td class="paramname">policy</td><td>Policy class describing kernel execution configuration. </td></tr>
    <tr><td class="paramname">cuda_stream</td><td>Which stream should schedule this operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae882322e35cc449a26a77adbf658bee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae882322e35cc449a26a77adbf658bee2">&#9670;&nbsp;</a></span>transformPosition() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInView , typename TOutView , typename TFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bolt::transformPosition </td>
          <td>(</td>
          <td class="paramtype">TInView&#160;</td>
          <td class="paramname"><em>in_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutView&#160;</td>
          <td class="paramname"><em>out_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunctor&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>cuda_stream</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies an operation on each element of the input view and stores the result in the output view, Functor obtains also element index as an argument together with element value. Both views must have same size Input and output view can the same if the functor does not have side effects changing the data in passed views. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_view</td><td>Input view, can be read only. </td></tr>
    <tr><td class="paramname">out_view</td><td>Output view - must provide write access. </td></tr>
    <tr><td class="paramname">functor</td><td>Applied callable object </td></tr>
    <tr><td class="paramname">cuda_stream</td><td>Id of the cuda stream on which the code will be executed (valid only for device/hybrid views) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga16275587bbe5ea1b2cb24705550761e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16275587bbe5ea1b2cb24705550761e2">&#9670;&nbsp;</a></span>transformPosition() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TInView , typename TOutView , typename TFunctor , typename TPolicy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bolt::transformPosition </td>
          <td>(</td>
          <td class="paramtype">TInView&#160;</td>
          <td class="paramname"><em>in_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TOutView&#160;</td>
          <td class="paramname"><em>out_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TFunctor&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TPolicy&#160;</td>
          <td class="paramname"><em>policy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>cuda_stream</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Applies an operation on each element of the input view and stores the result in the output view, Functor obtains also element index as an argument together with element value. Both views must have same size Input and output view can the same if the functor does not have side effects changing the data in passed views. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_view</td><td>Input view, can be read only. </td></tr>
    <tr><td class="paramname">out_view</td><td>Output view - must provide write access. </td></tr>
    <tr><td class="paramname">functor</td><td>Applied callable object </td></tr>
    <tr><td class="paramname">policy</td><td>Policy class describing kernel execution configuration. </td></tr>
    <tr><td class="paramname">cuda_stream</td><td>Id of the cuda stream on which the code will be executed (valid only for device/hybrid views) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup___algorithms_html_ga319d2dfacd54de6c44ab5c986291fe0e"><div class="ttname"><a href="group___algorithms.html#ga319d2dfacd54de6c44ab5c986291fe0e">bolt::reduce</a></div><div class="ttdeci">TOutputValue reduce(TView view, TOutputValue initial_value, TOperator reduction_operator, ExecutionPolicy execution_policy=ExecutionPolicy{})</div><div class="ttdef"><b>Definition:</b> reduce.tcc:412</div></div>
<div class="ttc" id="anamespacebolt_html_aa174a77eeaf258383cd6cd6ce0696213"><div class="ttname"><a href="namespacebolt.html#aa174a77eeaf258383cd6cd6ce0696213">bolt::view</a></div><div class="ttdeci">auto view(thrust::device_vector&lt; TElement &gt; &amp;buffer)</div><div class="ttdef"><b>Definition:</b> array_view.h:258</div></div>
<div class="ttc" id="agroup___vector_operations_html_gae14379204bbc3f89b945a150de5c6a87"><div class="ttname"><a href="group___vector_operations.html#gae14379204bbc3f89b945a150de5c6a87">bolt::sum</a></div><div class="ttdeci">BOLT_DECL_HYBRID TVector::Element sum(const TVector &amp;v)</div></div>
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
